"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compileTemplate = compileTemplate;
exports.handleNotify = handleNotify;
exports.notify = notify;
exports.sendNotification = sendNotification;
var _debug = _interopRequireDefault(require("debug"));
var _handlebars = _interopRequireDefault(require("handlebars"));
var _logger = require("@verdaccio/logger");
var _notifyRequest = require("./notify-request");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/* eslint-disable no-undef */

const debug = (0, _debug.default)('verdaccio:hooks');
function compileTemplate(content, metadata) {
  // FUTURE: multiple handlers
  return new Promise((resolve, reject) => {
    let handler;
    try {
      if (!handler) {
        debug('compile default template handler %o', content);
        const template = _handlebars.default.compile(content);
        return resolve(template(metadata));
      }
    } catch (error) {
      debug('error  template handler %o', error);
      reject(error);
    }
  });
}
async function handleNotify(metadata, notifyEntry, remoteUser, publishedPackage) {
  let regex;
  if (metadata.name && notifyEntry.packagePattern) {
    regex = new RegExp(notifyEntry.packagePattern, notifyEntry.packagePatternFlags || '');
    if (!regex.test(metadata.name)) {
      return false;
    }
  }
  let content;
  // FIXME: publisher is not part of the expected types metadata
  // @ts-ignore
  if (typeof metadata?.publisher === 'undefined' || metadata?.publisher === null) {
    // @ts-ignore
    metadata = {
      ...metadata,
      publishedPackage,
      publisher: {
        name: remoteUser.name
      }
    };
    debug('template metadata %o', metadata);
    content = await compileTemplate(notifyEntry.content, metadata);
  }
  const options = {
    body: JSON.stringify(content)
  };

  // provides fallback support, it's accept an Object {} and Array of {}
  if (notifyEntry.headers && Array.isArray(notifyEntry.headers)) {
    const header = {};
    // FIXME: we can simplify this
    notifyEntry.headers.map(function (item) {
      if (Object.is(item, item)) {
        for (const key in item) {
          /* eslint no-prototype-builtins: 0 */
          if (item.hasOwnProperty(key)) {
            header[key] = item[key];
          }
        }
      }
    });
    options.headers = header;
  } else if (Object.is(notifyEntry.headers, notifyEntry.headers)) {
    options.headers = notifyEntry.headers;
  }
  if (!notifyEntry.endpoint) {
    debug('error due endpoint is missing');
    throw new Error('missing parameter');
  }
  return (0, _notifyRequest.notifyRequest)(notifyEntry.endpoint, {
    method: notifyEntry.method,
    ...options
  });
}
function sendNotification(metadata, notify, remoteUser, publishedPackage) {
  return handleNotify(metadata, notify, remoteUser, publishedPackage);
}
async function notify(metadata, config, remoteUser, publishedPackage) {
  debug('init send notification');
  if (config.notify) {
    const isSingle = Object.keys(config.notify).includes('method');
    if (isSingle) {
      debug('send single notification');
      try {
        const response = await sendNotification(metadata, config.notify, remoteUser, publishedPackage);
        return [response];
      } catch {
        debug('error on sending single notification');
        return [false];
      }
    } else {
      debug('send multiples notification');
      const results = await Promise.allSettled(Object.keys(config.notify).map(keyId => {
        // @ts-ignore
        const item = config.notify[keyId];
        debug('send item %o', item);
        return sendNotification(metadata, item, remoteUser, publishedPackage);
      })).catch(error => {
        _logger.logger.error({
          error
        }, 'notify request has failed: @error');
      });

      // @ts-ignore
      return Object.keys(results).map(promiseValue => results[promiseValue].value);
    }
  } else {
    debug('no notifications configuration detected');
    return [false];
  }
}
//# sourceMappingURL=notify.js.map